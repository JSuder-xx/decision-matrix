// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "bs-platform/lib/es6/list.js";
import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Printf from "bs-platform/lib/es6/printf.js";
import * as $$String from "bs-platform/lib/es6/string.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Belt_List from "bs-platform/lib/es6/belt_List.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";

function swap(f, a, b) {
  return Curry._2(f, b, a);
}

var FuncEx = {
  swap: swap
};

var Either = { };

function choosei(trans, list) {
  return List.flatten(List.mapi((function (index, item) {
                    var match = Curry._2(trans, index, item);
                    if (match !== undefined) {
                      return /* :: */[
                              Caml_option.valFromOption(match),
                              /* [] */0
                            ];
                    } else {
                      return /* [] */0;
                    }
                  }), list));
}

function map_while_ok(trans, list) {
  var _acc = /* [] */0;
  var _param = list;
  while(true) {
    var param = _param;
    var acc = _acc;
    if (param) {
      var match = Curry._1(trans, param[0]);
      if (match.tag) {
        return /* Error */Block.__(1, [match[0]]);
      } else {
        _param = param[1];
        _acc = /* :: */[
          match[0],
          acc
        ];
        continue ;
      }
    } else {
      return /* Ok */Block.__(0, [List.rev(acc)]);
    }
  };
}

function compare_fst(param, param$1) {
  return Caml_obj.caml_compare(param[0], param$1[0]);
}

function move(from_index, to_before_index, list) {
  if (from_index === to_before_index) {
    return list;
  } else {
    return List.map((function (prim) {
                  return prim[1];
                }), List.sort(compare_fst, List.mapi((function (idx, item) {
                          if (idx === from_index) {
                            return /* tuple */[
                                    (to_before_index << 1) - 1 | 0,
                                    item
                                  ];
                          } else {
                            return /* tuple */[
                                    (idx << 1),
                                    item
                                  ];
                          }
                        }), list)));
  }
}

function find_opt(pred, list) {
  try {
    return Caml_option.some(List.find(pred, list));
  }
  catch (exn){
    return ;
  }
}

function remove_index(index, list) {
  return Belt_List.keepWithIndex(list, (function (param, idx) {
                return idx !== index;
              }));
}

var ListEx = {
  choosei: choosei,
  map_while_ok: map_while_ok,
  compare_fst: compare_fst,
  move: move,
  find_opt: find_opt,
  remove_index: remove_index
};

function case_insensitive_equal(left, right) {
  return $$String.lowercase($$String.trim(left)) === $$String.lowercase($$String.trim(right));
}

var StringEx = {
  case_insensitive_equal: case_insensitive_equal
};

function verify_new_name(name, name_list) {
  var cleaned_name = $$String.trim(name);
  if (cleaned_name.length < 1) {
    return /* Error */Block.__(1, ["Required"]);
  } else if (List.exists((function (param) {
            return case_insensitive_equal(cleaned_name, param);
          }), name_list)) {
    return /* Error */Block.__(1, [Curry._1(Printf.sprintf(/* Format */[
                        /* Char_literal */Block.__(12, [
                            /* "'" */39,
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    "' already in list. Try a different name.",
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "'%s' already in list. Try a different name."
                      ]), name)]);
  } else {
    return /* Ok */Block.__(0, [cleaned_name]);
  }
}

function verify_existing_name(name, name_list) {
  if (List.exists((function (param) {
            return Caml_obj.caml_equal(name, param);
          }), name_list)) {
    return /* Ok */Block.__(0, [/* () */0]);
  } else {
    return /* Error */Block.__(1, [Curry._1(Printf.sprintf(/* Format */[
                        /* Char_literal */Block.__(12, [
                            /* "'" */39,
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    "' cannot be found in the list",
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "'%s' cannot be found in the list"
                      ]), name)]);
  }
}

function find_name_index(name_to_find, name_list) {
  var match = choosei((function (idx, name) {
          if (case_insensitive_equal(name_to_find, name)) {
            return idx;
          }
          
        }), name_list);
  if (match) {
    if (match[1]) {
      return /* Error */Block.__(1, [Curry._1(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "Multiple with name ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "Multiple with name %s"
                        ]), name_to_find)]);
    } else {
      return /* Ok */Block.__(0, [match[0]]);
    }
  } else {
    return /* Error */Block.__(1, [Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "Unable to find '",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Char_literal */Block.__(12, [
                                    /* "'" */39,
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "Unable to find '%s'"
                      ]), name_to_find)]);
  }
}

var Names = {
  verify_new_name: verify_new_name,
  verify_existing_name: verify_existing_name,
  find_name_index: find_name_index
};

function map(fn, param) {
  if (param.tag) {
    return /* Error */Block.__(1, [param[0]]);
  } else {
    return /* Ok */Block.__(0, [Curry._1(fn, param[0])]);
  }
}

function $$return(value) {
  return /* Ok */Block.__(0, [value]);
}

function flatten(param) {
  if (param.tag) {
    return /* Error */Block.__(1, [param[0]]);
  } else {
    return param[0];
  }
}

function flatMap(fn, param) {
  if (param.tag) {
    return /* Error */Block.__(1, [param[0]]);
  } else {
    return Curry._1(fn, param[0]);
  }
}

function map2(fn, left_result, right_result) {
  return flatMap((function (left_value) {
                return map((function (right_value) {
                              return Curry._2(fn, left_value, right_value);
                            }), right_result);
              }), left_result);
}

function getExnFailWith(param) {
  if (param.tag) {
    return Pervasives.failwith(param[0]);
  } else {
    return param[0];
  }
}

function getExn(param) {
  if (param.tag) {
    throw param[0];
  } else {
    return param[0];
  }
}

var ResultEx = {
  map: map,
  $$return: $$return,
  flatten: flatten,
  join: flatten,
  flatMap: flatMap,
  map2: map2,
  getExnFailWith: getExnFailWith,
  getExn: getExn
};

export {
  FuncEx ,
  Either ,
  ListEx ,
  StringEx ,
  Names ,
  ResultEx ,
  
}
/* No side effect */
