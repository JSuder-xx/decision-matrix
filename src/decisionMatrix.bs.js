// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "bs-platform/lib/es6/list.js";
import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Table from "./table.bs.js";
import * as Utils from "./utils.bs.js";
import * as Printf from "bs-platform/lib/es6/printf.js";
import * as $$String from "bs-platform/lib/es6/string.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Belt_List from "bs-platform/lib/es6/belt_List.js";
import * as Caml_int32 from "bs-platform/lib/es6/caml_int32.js";
import * as Caml_format from "bs-platform/lib/es6/caml_format.js";

function $$default(param) {
  return 0;
}

function of_string(s) {
  try {
    return Caml_format.caml_int_of_string($$String.trim(s));
  }
  catch (exn){
    return ;
  }
}

function to_string(prim) {
  return String(prim);
}

var IntCellValue = {
  $$default: $$default,
  of_string: of_string,
  to_string: to_string
};

var DecisionMatrixTable = Table.MakeTable(IntCellValue);

function dimension_name_string(param) {
  if (param.tag) {
    return Curry._1(DecisionMatrixTable.string_of_row_name, param[0]);
  } else {
    return Curry._1(DecisionMatrixTable.string_of_column_name, param[0]);
  }
}

var string_of_factor_name = DecisionMatrixTable.string_of_column_name;

var string_of_alternative_name = DecisionMatrixTable.string_of_row_name;

var weights_name_string = "Weight";

function factor_names(t) {
  return Curry._1(DecisionMatrixTable.column_names, t);
}

var empty = Utils.ResultEx.getExnFailWith(Curry._2(DecisionMatrixTable.row_editing[/* add */0], Curry._1(DecisionMatrixTable.empty, /* () */0), weights_name_string));

function weights_row(table) {
  return List.find((function (row) {
                return Curry._1(DecisionMatrixTable.row_name_string, row) === weights_name_string;
              }), Curry._1(DecisionMatrixTable.rows, table));
}

function weight_cells(table) {
  var weights_row$1 = weights_row(table);
  var cells = Belt_List.zip(Curry._1(DecisionMatrixTable.column_names, table), Curry._1(DecisionMatrixTable.row_cells, weights_row$1));
  return /* tuple */[
          Curry._1(DecisionMatrixTable.row_name, weights_row$1),
          cells
        ];
}

function alternatives(table) {
  var weight_cells$1 = weight_cells(table)[1];
  var score_of = function (row) {
    return List.fold_left((function (prim, prim$1) {
                  return prim + prim$1 | 0;
                }), 0, List.map((function (param) {
                      return Caml_int32.imul(param[0], param[1][1]);
                    }), Belt_List.zip(Curry._1(DecisionMatrixTable.row_cells, row), weight_cells$1)));
  };
  return List.map((function (row) {
                return /* record */[
                        /* name */Curry._1(DecisionMatrixTable.row_name, row),
                        /* values */Belt_List.zip(Curry._1(DecisionMatrixTable.column_names, table), Curry._1(DecisionMatrixTable.row_cells, row)),
                        /* score */score_of(row)
                      ];
              }), List.filter((function (row) {
                      return Curry._1(DecisionMatrixTable.row_name_string, row) !== weights_name_string;
                    }))(Curry._1(DecisionMatrixTable.rows, table)));
}

var decorated = DecisionMatrixTable.column_editing;

var factor_editing_001 = /* add */decorated[/* add */0];

var factor_editing_002 = /* remove */decorated[/* remove */1];

var factor_editing_003 = /* change_name */decorated[/* change_name */2];

var factor_editing_004 = /* move */decorated[/* move */3];

var factor_editing = /* record */[
  /* label */"Factor",
  factor_editing_001,
  factor_editing_002,
  factor_editing_003,
  factor_editing_004
];

var decorated$1 = DecisionMatrixTable.row_editing;

var add = decorated$1[/* add */0];

function remove(table, with_name) {
  var weights_row$1 = weights_row(table);
  if (Caml_obj.caml_equal(with_name, Curry._1(DecisionMatrixTable.row_name, weights_row$1))) {
    return /* Error */Block.__(1, [Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "Cannot remove the ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Char_literal */Block.__(12, [
                                    /* "." */46,
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "Cannot remove the %s."
                      ]), weights_name_string)]);
  } else {
    return Curry._2(decorated$1[/* remove */1], table, with_name);
  }
}

function change_name(table, old_name, new_name) {
  var weights_row$1 = weights_row(table);
  if (Caml_obj.caml_equal(old_name, Curry._1(DecisionMatrixTable.row_name, weights_row$1))) {
    return /* Error */Block.__(1, [Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "Cannot rename ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Char_literal */Block.__(12, [
                                    /* "." */46,
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "Cannot rename %s."
                      ]), weights_name_string)]);
  } else {
    return Curry._3(decorated$1[/* change_name */2], table, old_name, new_name);
  }
}

function move(table, moving, to_after) {
  var weights_row$1 = weights_row(table);
  if (Caml_obj.caml_equal(moving, Curry._1(DecisionMatrixTable.row_name, weights_row$1))) {
    return /* Error */Block.__(1, [Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "Cannot move ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Char_literal */Block.__(12, [
                                    /* "." */46,
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "Cannot move %s."
                      ]), weights_name_string)]);
  } else if (Caml_obj.caml_equal(to_after, Curry._1(DecisionMatrixTable.row_name, weights_row$1))) {
    return /* Error */Block.__(1, [Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "Cannot move to before ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Char_literal */Block.__(12, [
                                    /* "." */46,
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "Cannot move to before %s."
                      ]), weights_name_string)]);
  } else {
    return Curry._3(decorated$1[/* move */3], table, moving, to_after);
  }
}

var alternative_editing = /* record */[
  /* label */"Alternative",
  /* add */add,
  /* remove */remove,
  /* change_name */change_name,
  /* move */move
];

function update_cell(matrix, factor_name, alternative_name, new_value) {
  return Curry._4(DecisionMatrixTable.update_cell_from_string, matrix, factor_name, alternative_name, new_value);
}

function decode(s) {
  return Curry._1(DecisionMatrixTable.decode, s);
}

function encode(matrix) {
  return Curry._1(DecisionMatrixTable.encode, matrix);
}

var DecisionMatrix = {
  dimension_name_string: dimension_name_string,
  string_of_factor_name: string_of_factor_name,
  string_of_alternative_name: string_of_alternative_name,
  factor_names: factor_names,
  weight_cells: weight_cells,
  alternatives: alternatives,
  empty: empty,
  factor_editing: factor_editing,
  alternative_editing: alternative_editing,
  update_cell: update_cell,
  decode: decode,
  encode: encode
};

export {
  IntCellValue ,
  DecisionMatrix ,
  
}
/* DecisionMatrixTable Not a pure module */
